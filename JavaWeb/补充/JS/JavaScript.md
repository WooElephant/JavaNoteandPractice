# JavaScript

## 原型

> 创建的每一个函数，解析器都会向其中增加一个prototype属性
>
> 这个属性对应着一个对象，这个对象就是其原型对象

> 当函数以构造函数形式调用，创建对象时，该对象中就会有隐含属性（\__proto__），指向prototype

> 可以向原型对象中添加属性，以至于它的后代都可以访问到此属性

> prototype也有\__proto__，直到找到Object对象

> **感觉就是Java中的Object，只不过是隐式继承**



## 执行上下文

> 在执行全局代码前，将window确定为全局执行上下文。对全局数据进行预处理
>
> var定义的变量（默认值undefined），添加为window的属性
>
> function定义的全局函数（默认值函数名()），添加为window的方法
>
> this（默认值window）
>
> 然后再执行全局代码

> 在调用函数时，创建执行上下文对象
>
> 形参赋值实参，添加为上下文的属性
>
> arguments赋值实参列表，添加为上下文的属性
>
> var定义的变量（默认值undefined），添加为上下文的属性
>
> function定义的全局函数（默认值函数名()），添加为上下文的方法
>
> this（默认值调用函数的对象）
>
> 然后开始执行函数体



## 闭包

> 当一个嵌套的内部，引用了外部的变量时，就产生了闭包

> 闭包是嵌套的内部函数
>
> 包含被引用变量的对象

```js
function fn1(){
    var a = 2;
    function fn2 (){
        a++;
        console.log(a);
    }
    return fn2;
}
var f = fn1();
f();	//3
f();	//4
```

> 闭包可以让函数内部变量执行完后，仍然存活在内存中
>
> 让函数外部可以操作内部数据

> 在嵌套的内部函数定义执行完成就产生了闭包
>
> 在嵌套内部函数称为垃圾时，闭包死亡



## 继承模式

### 原型链继承

> 让子类的prototype指向父类
>
> 子.prototype = new 父();

> 一般我们还喜欢将
>
> 子.prototype.constructor = 子
>
> 让他的Constructor指向自己，而不是父类



